# Lesson 2. Node js основы

- Архитектура REST. RESTful API
- Semver
- Объект global, глобальные переменные
- Работа с каталогами
- Работа с файлами

## Архитектура REST. RESTful API

REST — REpresentational State Transfer. Это передача/изменения состояния через представления. REST — это архитектурный стиль, некоторое множество ограничений, для построения распределенных приложений.

Архитектура REST описывается следующими ограничениями. 

- [Единый интерфейс (Uniform Interface)](http://www.restapitutorial.ru/lessons/whatisrest.html#uniform-interface)
- [Отсутствие состояний (Stateless)](http://www.restapitutorial.ru/lessons/whatisrest.html#stateless)
- [Кеширование ответа (Cacheable)](http://www.restapitutorial.ru/lessons/whatisrest.html#cacheable)
- [Клиент-сервер (Client-Server)](http://www.restapitutorial.ru/lessons/whatisrest.html#client-server)
- [Многоуровневая система (Layered System)](http://www.restapitutorial.ru/lessons/whatisrest.html#layered-system)

Чем больше ограничений вы выполните, тем более "full" получится приложение. В теории при выполнении всех требований вы получайте **RESTful** приложение, если соблюдать только часть из них это **REST-like**.

Ключевое понятие в REST — это ресурс. Ресурс имеет состояние, и мы можем его получать или изменять при помощи представлений. Наше приложение отвечает за некоторое множество таких ресурсов. Кстати, совокупное состояние ресурсов — это и есть состояние приложения.

Примеры ресурсов:

- Пользователи системы
- Курсы, в которых зарегистрирован студент
- История сообщений пользователя
- Пользователь
- Товар магазина
- Товары магазина
- Категория товаров магазина
- Категории товаров магазина

Чтобы создать нового покупателя в системе мы используем:

`POST http://www.example.com/customer`

Чтобы создать новый товар мы используем:

`POST http://www.example.com/product`

Для чтения, обновления, удаления продукта с id `66432`.

`GET|PUT|DELETE http://www.example.com/products/66432`

Чтобы получить информацию о товаре с id `12345` мы используем :

`GET http://www.example.com/product/12345`  

Тот же URI мы используем для PUT и DELETE, чтобы обновлять и удалять, соответственно.

Ниже предложен URI для получения всех продуктов:

`GET http://www.example.com/products`

Продуктов определенной категории:

`GET http://www.example.com/auto/products`


Каждый ресурс сервиса должен иметь хотя бы один URI, идентифицирующий его. И лучше всего, когда этот URI имеет смысл и адекватно описывает этот ресурс. URI должны иметь предсказуемую структуру.

Под представлением можно понимать JSON/HTML/XML/текст в определенном формате или что угодно, что позволяет нам понимать состояние ресурса или его модифицировать.

### Статьи
- [Именование ресурсов](http://www.restapitutorial.ru/lessons/restfulresourcenaming.html)
- [Понимание REST](https://dou.ua/lenta/articles/rest-conception/)


## SEMVER

Когда мы устанавливаем какой-то пакет, например, express, то в package.json добавляется последняя версия пакета, состоящая из трех цифр. Эти цифры означают Major, Minor, Patch и используют как спецификацию semver.

Что это значит? Когда я делаю пакет и еще не опубликовал его, то первая цифра идет 0. Это значит, что какие бы номера версий не шли дальше, я могу в любом момент менять любой функционал пакета. Потому что пакет, начинающийся с 0 - нестабильный пакет.

Когда мы опубликовали пакет, то каждый номер версии начинает иметь смысл. Последняя цифра - это PATCH. То есть внесение незначительных изменений в пакет, например bugfix.

Средняя цифра - это минорная версия. Она должна обновляться при изменениях, которые добавляют новый функционал, но не ломают то, что уже работает. Таким образом любой человек может обновится с 1.2.0 на 1.3.0 и все должно по прежнему работать.

Первая же цифра - это мажорная версия. Если внеслись хоть какие-то изменения, которые сломали текущий код, то должна релизится новая мажорная версия. Это может быть как изменение API, так и изменение порядка аргументов. Поэтому нужно делать версию 2.0.0.

Собственно вся система версий и пакетов подчиняется спецификации semver.

Мы можем указать, что пакет должен быть больше версии 1.2.7

`>= 1.2.7`

Тогда, при установке пакетов версия будет искаться только среди версий, которые больше 1.2.7.

Также можно указывать range.

`>=1.2.7 <1.3.0`

Также есть специальные пре релизные теги.

`1.2.3-alpha.3`
`1.2.3-beta.0`

Также часто встречаются тильда и каретка.

Когда у нас стоит тильда

`~1.2.3`
Это значит, что версия может меняться только от 1.2.3 до 1.3.0, то есть могут применятся только патчи, а минорная версия обновлятся не может.

Если же у нас стоит каретка

`^1.2.3`
То можно обновлять и минорную версию и накатывать патчи. То есть от 1.2.3 до 2.0.0.

[Видео с обьяснением](https://monsterlessons.com/project/lessons/razbiraemsya-s-versiyami-paketov-v-node)

## Объект global, глобальные переменные

Node.js предоставляет специальный объект `global`, который предоставляет доступ к глобальным, то есть доступным из каждого модуля приложения, переменным и функциям. 

Примерным аналогом данного объекта в javascript для браузера является объект `window`. Все доступные глобальные объекты можно посмотреть в [документации](https://nodejs.org/api/globals.html).

Примеры глобальных переменных:

- `__filename` указывает имя файла который в настоящее время выполняется. Абсолютный путь к месту где находится файл. 
- `__dirname` указывает адрес каталога где лежит файл что сейчас выполняется. Абсолютный путь к месту где находится каталог.
- `setInterval, setTimeout`
- `process`

[Документация на русском](http://www.w3big.com/ru/nodejs/nodejs-global-object.html)

Рекомендуется избегать определения и использования глобальных переменных, и преимущественно ориентироваться на создание переменных, инкапсулированных в рамках отдельных модулей.

[Статья с примером](https://metanit.com/web/nodejs/2.3.php)

## Синхронность, асинхронность процессов

### Event loop
[Статья об ивент луп](https://medium.com/front-end-hacking/javascript-event-loop-explained-4cd26af121d4)
[Видео об ивент луп](https://medium.com/front-end-hacking/javascript-event-loop-explained-4cd26af121d4)

## Работа с каталогами

В Node JS есть модуль отвечающий за работу с директориями и файлами. Он называется fs (file system).

#### Проверить существует ли директория 

`fs.existsSync(path)`

ВАЖНО! `fs.exists(path,cb)` deprecated, по этому нужно использовать только его синхронный аналог.


#### Создание директории

`fs.mkdir(path[, mode], callback);`

- `path` — это имя директории, включая путь к ней.
- `mode` – это права доступа к директории. По умолчанию — 0777.
- `callback` — это функция обратного вызова. Никакие аргументы кроме возможных исключений не передаются функции обратного вызова завершения.

Пример

```
var fs = require("fs");
 
console.log("Going to create directory /tmp/test");
fs.mkdir('/tmp/test',function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Directory created successfully!");
});
```

#### Чтение директории

`fs.readdir(path, callback);`

Пример
```
var fs = require("fs");
 
console.log("Going to read directory /tmp");
fs.readdir("/tmp/",function(err, files){
   if (err) {
      return console.error(err);
   }
   files.forEach( function (file){
      console.log( file );
   });
});
```

#### Удаление директории

`fs.rmdir(path, callback)`

Пример

```
var fs = require("fs");
 
console.log("Going to delete directory /tmp/test");
fs.rmdir("/tmp/test",function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Going to read directory /tmp");
   
   fs.readdir("/tmp/",function(err, files){
      if (err) {
         return console.error(err);
      }
      files.forEach( function (file){
         console.log( file );
      });
   });
});
```

[Видое о работе с директориями](https://www.youtube.com/watch?v=GlsyhBFfrgg)

## Работа с файлами

Пример чтения файла

```
var fs = require("fs");
 
// Asynchronous read
fs.readFile('input.txt', function (err, data) {
   if (err) {
      return console.error(err);
   }
   console.log("Asynchronous read: " + data.toString());
});
 
// Synchronous read
var data = fs.readFileSync('input.txt');
console.log("Synchronous read: " + data.toString());
 
console.log("Program Ended");
```

### Флаги для операций чтения/записи :

`r `— Открыть файл для чтения. Если файл не существует, добавляется исключение.

`г+` — Открыть файл для чтения и записи. Если файл не существует, добавляется исключение.

`rs `— Открыть файл для чтения в синхронном режиме.

`rs+` — Открыть файл для чтения и записи, запросив у ОС открыть его в синхронном режиме.

`w `— Открыть файл для записи. Файл создается (если он не существует) или усекается (если он существует).

`wx `— Работает так же как «w», но не выполняется, если путь существует.

`w+` — Открыть файл для чтения и записи. Если файл не существует, он создается, если файл существует, он усекается.

`wx+` — Работает так же как «w+», но не выполняется, если путь существует.

`a `— Открыть файл для дополнения. Если файл не существует, он создается.

`ax `— Работает как «а», но не выполняется, если путь существует.

`a+` — Открыть файл для чтения и расширения. Если файл не существует, он создается.

`ах`+ — Работает так же как «a+», но не выполняется, если путь существует.


#### Пример

```
// fs_write.js

const fs = require('fs');

// Путь к файлу который мы хотим изменить
let path = 'ghetto_gospel.txt';  
let buffer = new Buffer('Those who wish to follow me\nI welcome with my hands\nAnd the red sun sinks at last');

// открыть файл в режиме записи, добавить коллбек в котором сделать запись в файл
fs.open(path, 'w', function(err, fd) {  
    if (err) {
        throw 'could not open file: ' + err;
    }

    // записать контент в буфер с позиции 0 до конца 
    fs.write(fd, buffer, 0, buffer.length, null, function(err) {
        if (err) throw 'error writing file: ' + err;
        
        // Завершить изменение файла
        fs.close(fd, function() {
            console.log('wrote the file successfully');
        });
    });
```

Для перезаписи файла можно использовать более простой метод `fs.writeFile()`

[Статья "Как писать данные в файлы"](https://stackabuse.com/writing-to-files-in-node-js/)

```
var fs = require('fs');

fs.writeFile('mynewfile3.txt', 'This is my text', function (err) {
  if (err) throw err;
  console.log('Replaced!');
});
```

#### Запись файла
`fs.writeFile(filename, data[, options], callback)`

Этот метод перезаписывает файл, если файл уже существует. Если вы хотите дописать что-то в существующий файл, вы должны использовать другой доступный метод.

###  Переименовать файл

`fs.rename(new_file_path, old_file_path, callback_function)`

#### Удаление файла

`fs.unlink(path, callback)`

```
var fs = require("fs");
 
console.log("Going to delete an existing file");
fs.unlink('input.txt', function(err) {
   if (err) {
      return console.error(err);
   }
   console.log("File deleted successfully!");
});
```

#### Получение информации о файлах

`fs.stat(path, callback)`

Чаще всего используемы только эти 2 метода:

`stats.isFile()` — Возвращает true, если тип файла — простой файл.

`stats.isDirectory()` — Возвращает true, если тип файла — каталог.


[Статья о работе с файлами и директориями](https://webformyself.com/node-js-fs-fajlovaya-sistema/)

### Задание:

Это должен быть второй пул реквест в ваш репозиторий с домашним заданием.
За основу нужно взять проект из домашнего задания 1.

- для эндпоинта POST `/products` (создание товара) сделать валидацию входных данных которые приходят с клиента. 

    - когда отсылаете на бекенд 
    ```
    {
     "name": "Квартира",
     "description": "Хорошая квартира в центре города",
     "price": "20000",
     "currency": "USD",
    }
    ```
    и забыли указать `"categories": ["house", "rent"]` или любое другое поле, то в ответе с бекенда должен прийти следующий ответ
    `{ "error": "'categories' missing" }` либо же други поля что не были отправлены серверу. 
    
    Если полей пропущено несколько, то нужно в ответе перечислить их все. 
- для эндпоинта POST `/users` сделать то же самое 
- создать эндпоинт POST `/categories` для создания категорий
    - принимает 
        ```
        {
         "name": "Недвижимость",
         "description": "Категория для недвижимости",
        }
        ```
    - на бекенде к нему добавляется уникальный `id`
    - сохраняете их в `<category-name>.json`, который кладете в папку  `data/categories`
    - сделать валидацию как для POST `/products` и POST `/users`

#### Дополнительное задание

- добавить возможность загружать картинки для определенного товара
    - нужно создать новый эндпоинт POST `/images`
    - он должен принимать с фронтенда запрос со следующими данными:
        - картинка
        - id товара
    - в ответ сервер должен отправить 
       ```
       {
        "status": "success", 
        "imageSrc": <image-src>
       }
       ```
   - в идеале использовать `multipart/form-data` кодировку
   - попробуйте сделать без сторонних библиотек
       
   Статьи что помогут с загрузкой изображения:
    - https://codeburst.io/how-to-handle-multipart-form-data-in-nodejs-file-uploading-in-nodejs-26c0cb88adcf
    - https://developer.mozilla.org/ru/docs/Web/API/FormData/Using_FormData_Objects
   
#### Требования
   - Приложение должно лежать в отдельном вашем репозитории с названием `marketplace-server-goit`
   - Все задание нужно делать в ветке `homework-2`
   - После того как закончите задание нужно сделать pull request в ветку `master`
